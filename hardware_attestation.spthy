
/*
*  Author: Julian Pritzi
*  Model Name: hardware attestation
*  Status: DEVELOPMENTAL
*
*  Comments: This simplified model assumes a single ICU 
*/

theory HardwareAttestation
begin

heuristic: O "hardware_attestation_oracle.py"

builtins: hashing, signing, diffie-hellman, multiset

/*********************************************************************/
/* Rules for setting up initial state                                */
/*********************************************************************/
rule initialize_environment:
    let
      kernel_pub = pk(~kernel_priv)
      kernel_cert = <'cert', $Kernel, kernel_pub, sign(<'kernel', $Kernel, kernel_pub>, ~ca_priv)>
    in
    [ Fr(~ca_priv), Fr(~kernel_priv) ]
  --[ OnlyOnce(), KernelKey(~kernel_priv), CaKey(~ca_priv) ]->
    [ 
      !CaPriv(~ca_priv),
      !CaPub(pk(~ca_priv)), 
      !KernelPrivKey($Kernel, ~kernel_priv),
      !KernelCertificate($Kernel, kernel_cert),
      NextICUCounter('1'),
      TotalResetCounter('1'),
      
      Out(pk(~ca_priv)),
      Out(pk(kernel_cert))
    ]

rule register_icu:
    let
      icu_pub = pk(~icu_priv) 
      icu_cert = <'cert', $ICU, icu_pub, sign(<'icu', $ICU, icu_pub>, ~ca_priv)>
    in
    [
      Fr(~icu_priv),

      !CaPriv(~ca_priv),

      NextICUCounter(x)
    ]
  --[ IcuKey(~icu_priv), Unique($ICU), RegisterICU($ICU), RegisteredICUs(x) ]->
    [
      !ICUPrivKey($ICU, ~icu_priv),
      !ICUCertificate($ICU, icu_cert),
      UninitializedIcu($ICU),
      IcuResetCounter($ICU, '1'),
      NextICUCounter(x + '1'),

      Out(pk(icu_cert))
    ]

rule reset_icu:
    [ Icu_memory_1($ICU, ~dh_icu_priv, kernel_cert, ~n_icu), IcuResetCounter($ICU, x), TotalResetCounter(y) ]
  --[ ResetIcu($ICU, x + '1'), TotalResets(y + '1') ]->
    [ UninitializedIcu($ICU), IcuResetCounter($ICU, x + '1'), TotalResetCounter(y + '1') ]

/*********************************************************************/
/* Rules modeling the messages sent between Kernel and ICU           */
/*********************************************************************/
rule kernel_to_icu_1:
    let 
      n_kernel_sig_k = sign(<'kernel_nonce', ~n_kernel>, kernel_priv)
    in
    [ 
      Fr(~n_kernel),

      !KernelPrivKey($Kernel, kernel_priv),
      !KernelCertificate($Kernel, kernel_cert)
    ]
  --[  
      ProtocolStep('1'),
      BehaveKernel($Kernel) 
    ]->
    [ 
      Kernel_memory_1($Kernel, ~n_kernel),
      Out( <'1', ~n_kernel, n_kernel_sig_k, kernel_cert> )
    ]

rule icu_to_kernel_1:
    let
      n_kernel_sig_i = sign(<'kernel_nonce', n_kernel>, icu_priv)
      n_kernel_valid = verify(n_kernel_sig_k, <'kernel_nonce', n_kernel>, kernel_pub)

      kernel_cert = <'cert', kernel, kernel_pub, kernel_sig>
      kernel_cert_valid = verify(kernel_sig, <'kernel', kernel, kernel_pub>, ca_pub)

      dh_icu_pub = 'g' ^ ~dh_icu_priv
      icu_reply_sig = sign(<'icu_reply', ~n_icu, dh_icu_pub, n_kernel>, icu_priv)
    in
    [ 
      Fr(~n_icu), Fr(~dh_icu_priv),
      UninitializedIcu($ICU),

      In( <'1', n_kernel, n_kernel_sig_k, <'cert', kernel, kernel_pub, kernel_sig>> ),

      !ICUPrivKey($ICU, icu_priv),
      !ICUCertificate($ICU, icu_cert),
      !CaPub(ca_pub)
    ]
  --[ 
      Eq(kernel_cert_valid, true),
      Eq(n_kernel_valid, true),
      NotEq($ICU, kernel), 

      ICUReply($ICU, kernel, dh_icu_pub),

      ProtocolStep('2'),
      BehaveICU($ICU) 
    ]->
    [ 
      Icu_memory_1($ICU, ~dh_icu_priv, kernel_cert, ~n_icu),
      Out( <'2', ~n_icu, n_kernel_sig_i, dh_icu_pub, icu_reply_sig, icu_cert> )
    ]

rule kernel_to_icu_2:
    let 
      n_kernel_valid = verify(n_kernel_sig_i, <'kernel_nonce', n_kernel>, icu_pub)
      
      n_icu_sig_k = sign(<'icu_nonce', n_icu>, kernel_priv)

      icu_cert = <'cert', icu, icu_pub, icu_sig>
      icu_cert_valid = verify(icu_sig, <'icu', icu, icu_pub>, ca_pub)

      dh_kernel_pub = 'g' ^ ~dh_kernel_priv
      kernel_reply_sig = sign(<'kernel_reply', dh_kernel_pub, n_icu>, kernel_priv)

      icu_reply_valid = verify(icu_reply_sig, <'icu_reply', n_icu, dh_icu_pub, n_kernel>, icu_pub)
      dh_common = dh_icu_pub ^ ~dh_kernel_priv
    in
    [ 
      Kernel_memory_1($Kernel, n_kernel),
      Fr(~dh_kernel_priv),

      In( <'2', n_icu, n_icu_sig_i, n_kernel_sig_i, dh_icu_pub, icu_reply_sig, <'cert', icu, icu_pub, icu_sig>>),
      
      !KernelPrivKey($Kernel, kernel_priv),
      !CaPub(ca_pub)
    ]
  --[ 
      Eq(n_kernel_valid, true),
      Eq(icu_cert_valid, true),
      Eq(icu_reply_valid, true),
      NotEq($Kernel, icu), 

      KernelDone($Kernel, icu, dh_common),
      KernelTrust($Kernel, icu, dh_icu_pub),
      
      ProtocolStep('3'),
      BehaveKernel($Kernel)
    ]->
    [ 
      Out(<'3', n_icu_sig_k, dh_kernel_pub, kernel_reply_sig>)
    ]

rule icu_to_kernel_2:
    let 
      n_icu_valid = verify(n_icu_sig_k, <'icu_nonce', n_icu>, kernel_pub)

      kernel_reply_valid = verify(kernel_reply_sig, <'kernel_reply', dh_kernel_pub, n_icu>, kernel_pub)
      dh_common = dh_kernel_pub ^ dh_icu_priv
    in
    [ 
      Icu_memory_1($ICU, dh_icu_priv, <'cert', kernel, kernel_pub, kernel_sig>, n_icu),

      In(<'3', n_icu_sig_k, dh_kernel_pub, kernel_reply_sig>)
    ]
  --[ 
      Eq(n_icu_valid, true),
      Eq(kernel_reply_valid, true),
      NotEq($ICU, kernel), 

      ICUDone($ICU, kernel, dh_common),
      
      ProtocolStep('4'),
      BehaveICU($ICU) 
    ]-> 
    [ ]

/*********************************************************************/
/* Restrictions that can be used by rules for contolling transitions */
/*********************************************************************/
restriction equality:
  "All x y #i. Eq(x,y) @i ==> x = y"

restriction inequality:
  "All x y #i. NotEq(x,y) @i ==> not(x = y)"

restriction only_once:
  "All #i #j. OnlyOnce()@#i & OnlyOnce()@#j ==> #i = #j"

restriction uniqueness:
  "All x #i #j. Unique(x)@#i & Unique(x)@#j ==> #i = #j"
  

/*********************************************************************/
/* Properties to prove                                               */
/*********************************************************************/

/*
 * Proofs that the protocol can be sucessfully executed
 */
lemma valid_session_can_be_created:
  exists-trace
  " /* Guide the prover to construct a valid protocol flow, ie. use one icu and do not reset */
    (
      ( All icu1 icu2 #i #j. RegisterICU(icu1) @ #i & RegisterICU(icu2) @ #j ==> icu1 = icu2 )
      &  
      not (Ex icu x #i. ResetIcu(icu, x) @ #i)
    )
    &
    Ex kernel icu common_key #i #j.
      (
        KernelDone(kernel, icu, common_key) @ #i
        & ICUDone(icu, kernel, common_key) @ #j
      )
  "

/*
 * Proofs that the protocol does not leak the kernels private keys
 */
lemma attacker_does_not_know_kernel_keys: 
  " All kkey #i. 
      KernelKey(kkey) @ #i 
      ==> 
      ( not ( Ex #j. K(kkey) @ #j )) 
  "

/*
 * Proofs that the protocol does not leak the icus private keys
 */
lemma attacker_does_not_know_icu_keys: 
  " All ikey #i. 
      IcuKey(ikey) @ #i 
      ==> 
      ( not ( Ex #j. K(ikey) @ #j )) 
  "

/*
 * Proofs that the protocol does not leak the ca private keys
 */
lemma attacker_does_not_know_ca_keys: 
 " All cakey #i. 
    CaKey(cakey) @ #i 
     ==> 
     ( not ( Ex #j. K(cakey) @ #j )) 
 "

/*
 * Proofs that the symmetric key is secure
 */
lemma attacker_does_not_know_symmetric_keys: 
  " All num_icu #n. RegisteredICUs(num_icu) @ #n 
    ==>
      All reset_num #r. TotalResets(reset_num) @ #r
        ==>
        (
          All kernel icu common_key #i #j. 
          (
            KernelDone(kernel, icu, common_key) @ #i
            & ICUDone(icu, kernel, common_key) @ #j
          )
          ==>
          (
            not ( Ex #k. K(common_key) @ #k )
          )
        )
  "

lemma kernel_trust_means_icu_reply [use_induction]:
  " All num_icu #n. RegisteredICUs(num_icu) @ #n 
    ==>
      All reset_num #r. TotalResets(reset_num) @ #r
      ==>
        (
          All icu kernel key_material #i. 
          ( KernelTrust(kernel, icu, key_material) @ #i )
          ==>
          ( Ex #j. (#j < #i) & ICUReply(icu, kernel, key_material) @ #j )
        )
  "

/*
 * Proofs that the ICU trusting in a symmetic key means that the kernel set this key up with that icu
 */
lemma icu_done_means_kernel_done [use_induction]:
  " All num_icu #n. RegisteredICUs(num_icu) @ #n 
    ==>
      All reset_num #r. TotalResets(reset_num) @ #r
      ==>
        (
          All icu kernel common_key #i. 
          ( ICUDone(icu, kernel, common_key) @ #i )
          ==>
          ( Ex #j. (#j < #i) & KernelDone(kernel, icu, common_key) @ #j )
        )
  "

end
